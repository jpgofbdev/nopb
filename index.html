<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>NoPb ‚Äì Plans d‚Äôeau</title>
  <link rel="icon" href="data:,">

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin="">
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin=""></script>

  <style>
    html, body { height:100%; margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif; }
    #app { height:100%; display:grid; grid-template-rows:52px 1fr; }
    header{display:flex;justify-content:space-between;align-items:center;padding:0 12px;background:#fff;border-bottom:1px solid #e6e6e6;}
    .brand{display:flex;gap:10px;align-items:baseline;}
    .title{font-weight:750;font-size:18px;}
    .subtitle{font-size:12px;color:#666;}
    .toplinks a{margin-left:6px;text-decoration:none;border:1px solid #ddd;border-radius:8px;padding:4px 7px;background:#fff;}
    .toplinks a:hover{background:#f6f6f6;}
    #map{width:100%;height:100%;}
    .panel{position:absolute;left:12px;top:70px;z-index:1000;background:#fff;border:1px solid #cfcfcf;border-radius:10px;padding:10px;width:250px;box-shadow:0 6px 18px rgba(0,0,0,0.06);}
    .panel button{width:100%;padding:8px 10px;border-radius:8px;border:1px solid #cfcfcf;background:#fff;cursor:pointer;font-weight:600;}
    .panel button:hover{background:#f6f6f6;}
    .status{margin-top:8px;font-size:12px;line-height:1.35;color:#333;}
    .afficher{position:absolute;right:12px;top:70px;z-index:1000;background:#fff;border:1px solid #cfcfcf;border-radius:10px;padding:10px;width:170px;box-shadow:0 6px 18px rgba(0,0,0,0.06);font-size:13px;}
    .searchBox{position:absolute;right:12px;bottom:18px;z-index:1000;background:#fff;border:1px solid #cfcfcf;border-radius:10px;padding:8px;width:260px;box-shadow:0 6px 18px rgba(0,0,0,0.06);}
    .searchBox input{width:100%;padding:8px;box-sizing:border-box;border:1px solid #ddd;border-radius:8px;outline:none;}
    .searchBox input:focus{border-color:#b9b9b9;}
    #suggestions{margin-top:6px;border:1px solid #eee;border-radius:8px;overflow:hidden;display:none;background:#fff;max-height:240px;overflow-y:auto;}
    .suggestion{cursor:pointer;padding:8px 10px;font-size:13px;}
    .suggestion:hover{background:#f2f2f2;}
    @media (max-width:520px){.panel{width:210px}.searchBox{width:220px}.afficher{width:160px}.subtitle{display:none}}
  </style>
</head>

<body>
<div id="app">
  <header>
    <div class="brand">
      <div class="title">ü™® NoPb</div>
      <div class="subtitle">Plans d‚Äôeau ‚Ä¢ Parquet client-side</div>
    </div>
    <div class="toplinks">
      <a href="./documentation.html" title="Documentation">üìñ</a>
      <a href="./apropos.html" title="√Ä propos">‚ÑπÔ∏è</a>
    </div>
  </header>

  <div style="position:relative">
    <div id="map"></div>

    <div class="panel">
      <button id="btnLocate">üìç Localisez-moi</button>
      <div class="status" id="status">Initialisation‚Ä¶</div>
    </div>

    <div class="afficher">
      <b>Afficher :</b><br>
      <label><input type="checkbox" id="chkTampon" checked> tampon 100 m</label><br>
      <label><input type="checkbox" id="chkPlan" checked> plans d‚Äôeau</label>
    </div>

    <div class="searchBox">
      <input id="communeInput" placeholder="Commune (BAN)" autocomplete="off">
      <div id="suggestions"></div>
    </div>
  </div>
</div>

<script type="module">
  const SITE_BASE   = "/nopb";
  const DUCKDB_DIST = `${SITE_BASE}/vendor/duckdb/1.28.0/dist`;
  const PLAN_PARQUET   = `${SITE_BASE}/data/planDeau.parquet`;
  const TAMPON_PARQUET = `${SITE_BASE}/data/planDeau_tampon_100m.parquet`;

  const statusEl = document.getElementById("status");
  const setStatus = (s) => statusEl.textContent = s;

  /********************
   * LEAFLET
   ********************/
  const map = L.map("map", { zoomControl:false }).setView([46.6, 2.4], 6);

  const osm = L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png",
    { maxZoom:19, attribution:"&copy; OpenStreetMap" }).addTo(map);
  const carto = L.tileLayer("https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png",
    { maxZoom:20, attribution:"&copy; OSM &copy; CARTO" });
  const esri = L.tileLayer("https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}",
    { maxZoom:19, attribution:"Tiles &copy; Esri" });

  L.control.layers(
    { "OSM (d√©faut)": osm, "CARTO Light": carto, "Esri Satellite": esri },
    {},
    { collapsed:true, position:"bottomleft" }
  ).addTo(map);

  map.createPane("tampon"); map.getPane("tampon").style.zIndex = 410;
  map.createPane("plan");   map.getPane("plan").style.zIndex = 420;

  setTimeout(() => { try { map.locate({ setView:true, maxZoom:14, enableHighAccuracy:false, timeout:8000 }); } catch {} }, 350);
  document.getElementById("btnLocate").onclick = () =>
    map.locate({ setView:true, maxZoom:16, enableHighAccuracy:true, timeout:12000 });

  map.on("locationfound", (e) => setStatus(`Position trouv√©e (¬±${Math.round(e.accuracy)} m)`));
  map.on("locationerror", () => setStatus("Localisation impossible (autorisation refus√©e ou signal indisponible)."));

  /********************
   * BAN (communes)
   ********************/
  const inp = document.getElementById("communeInput");
  const sug = document.getElementById("suggestions");
  let banTimer = null;

  function clearSug(){ sug.innerHTML=""; sug.style.display="none"; }
  function showSug(features){
    sug.innerHTML="";
    if(!features?.length) return clearSug();
    for(const f of features){
      const div=document.createElement("div");
      div.className="suggestion";
      div.textContent=f.properties?.label || "Commune";
      div.onclick=() => {
        clearSug();
        const [lon,lat]=f.geometry.coordinates;
        map.setView([lat,lon],13);
        setStatus(`Zoom sur : ${div.textContent}`);
      };
      sug.appendChild(div);
    }
    sug.style.display="block";
  }

  inp.addEventListener("input", () => {
    const q=inp.value.trim();
    if(banTimer) clearTimeout(banTimer);
    if(q.length<3) return clearSug();
    banTimer=setTimeout(async () => {
      try{
        const r=await fetch(`https://api-adresse.data.gouv.fr/search/?q=${encodeURIComponent(q)}&type=municipality&autocomplete=1&limit=8`);
        const j=await r.json();
        showSug(j.features);
      }catch(e){
        console.warn(e);
        clearSug();
        setStatus("Recherche commune indisponible (BAN).");
      }
    },220);
  });
  inp.addEventListener("blur", () => setTimeout(clearSug,200));

  /********************
   * WKB ‚Üí GeoJSON (Polygon/MultiPolygon)
   ********************/
  function readUInt32(dv, o, le){ return dv.getUint32(o, le); }
  function readDouble(dv, o, le){ return dv.getFloat64(o, le); }

  function parseWKB(uint8) {
  const dv = new DataView(uint8.buffer, uint8.byteOffset, uint8.byteLength);
  let o = 0;

  const le = dv.getUint8(o) === 1; o += 1;

  let type = dv.getUint32(o, le); o += 4;

  // ---- Dimensions: EWKB flags (PostGIS) OR OGC type+1000/2000/3000 ----
  const ewkbHasZ    = (type & 0x80000000) !== 0;
  const ewkbHasM    = (type & 0x40000000) !== 0;
  const ewkbHasSRID = (type & 0x20000000) !== 0;

  let hasZ = ewkbHasZ;
  let hasM = ewkbHasM;
  let hasSRID = ewkbHasSRID;

  // EWKB base type
  let baseType = (type & 0x0fffffff);

  // OGC / SQL-MM: type + 1000/2000/3000
  // 1000 => Z, 2000 => M, 3000 => ZM
  if (type >= 3000 && type < 4000) {
    hasZ = true; hasM = true; hasSRID = false;
    baseType = type - 3000;
  } else if (type >= 2000 && type < 3000) {
    hasZ = false; hasM = true; hasSRID = false;
    baseType = type - 2000;
  } else if (type >= 1000 && type < 2000) {
    hasZ = true; hasM = false; hasSRID = false;
    baseType = type - 1000;
  }

  // SRID present only in EWKB
  if (hasSRID) { o += 4; }

  const dims = 2 + (hasZ ? 1 : 0) + (hasM ? 1 : 0);

  function readPoint() {
    const x = dv.getFloat64(o, le); o += 8;
    const y = dv.getFloat64(o, le); o += 8;
    // skip Z/M if present
    for (let k = 2; k < dims; k++) o += 8;
    return [x, y];
  }

  function readPolygonBody(localLE, localDims) {
    // assumes cursor o is positioned right before numRings
    const nr = dv.getUint32(o, localLE); o += 4;
    const rings = [];
    for (let r = 0; r < nr; r++) {
      const np = dv.getUint32(o, localLE); o += 4;
      const ring = new Array(np);
      for (let i = 0; i < np; i++) {
        const x = dv.getFloat64(o, localLE); o += 8;
        const y = dv.getFloat64(o, localLE); o += 8;
        for (let k = 2; k < localDims; k++) o += 8; // skip Z/M
        ring[i] = [x, y];
      }
      rings.push(ring);
    }
    return rings;
  }

  function readPolygon() {
    return readPolygonBody(le, dims);
  }

  if (baseType === 3) {
    return { type: "Polygon", coordinates: readPolygon() };
  }

  if (baseType === 6) {
    const n = dv.getUint32(o, le); o += 4;
    const polys = [];

    for (let p = 0; p < n; p++) {
      // Each polygon is a complete (E)WKB geometry
      const subLE = dv.getUint8(o) === 1;

      // Read subType (but do not advance cursor yet, we will advance properly)
      let subType = dv.getUint32(o + 1, subLE);

      // Determine sub geometry dims for BOTH conventions
      const subEwkbHasZ    = (subType & 0x80000000) !== 0;
      const subEwkbHasM    = (subType & 0x40000000) !== 0;
      const subEwkbHasSRID = (subType & 0x20000000) !== 0;

      let subHasZ = subEwkbHasZ;
      let subHasM = subEwkbHasM;
      let subHasSRID = subEwkbHasSRID;

      let subBaseType = (subType & 0x0fffffff);

      if (subType >= 3000 && subType < 4000) {
        subHasZ = true; subHasM = true; subHasSRID = false;
        subBaseType = subType - 3000;
      } else if (subType >= 2000 && subType < 3000) {
        subHasZ = false; subHasM = true; subHasSRID = false;
        subBaseType = subType - 2000;
      } else if (subType >= 1000 && subType < 2000) {
        subHasZ = true; subHasM = false; subHasSRID = false;
        subBaseType = subType - 1000;
      }

      if (subBaseType !== 3) {
        throw new Error(`MultiPolygon contient un sous-type non Polygon (baseType=${subBaseType})`);
      }

      // Advance into sub-geometry: byteOrder + type
      o += 1 + 4;

      // Skip SRID if present (EWKB only)
      if (subHasSRID) o += 4;

      const subDims = 2 + (subHasZ ? 1 : 0) + (subHasM ? 1 : 0);

      // Now read the polygon body at current cursor
      const rings = readPolygonBody(subLE, subDims);
      polys.push(rings);
    }

    return { type: "MultiPolygon", coordinates: polys };
  }

  throw new Error(`WKB type non g√©r√©: ${type} (baseType=${baseType})`);
}



  /********************
   * DUCKDB-WASM (MVP ONLY) + Parquet
   ********************/
  import * as duckdb from "https://cdn.jsdelivr.net/npm/@duckdb/duckdb-wasm@1.28.0/+esm";

  async function assertOk(url, label){
    const r = await fetch(url, { method:"GET" });
    if(!r.ok) throw new Error(`${label} introuvable : ${url} (HTTP ${r.status})`);
  }

  const MVP_WASM   = `${DUCKDB_DIST}/duckdb-mvp.wasm`;
  const MVP_WORKER = `${DUCKDB_DIST}/duckdb-browser-mvp.worker.js`;

  let tamponLayer = null;
  let planLayer = null;

  async function parquetToLayer(db, conn, url, pane, style){
    // on enregistre le fichier parquet dans le FS WASM
    const ab = await (await fetch(url)).arrayBuffer();
    await db.registerFileBuffer(url, new Uint8Array(ab));

    // On lit uniquement geometry ; le reste tu peux l‚Äôajouter ensuite
    const res = await conn.query(`
      SELECT geometry
      FROM read_parquet('${url}')
      WHERE geometry IS NOT NULL
    `);

    const geomCol = res.getChild("geometry");
    const feats = [];

    for(let i=0; i<res.numRows; i++){
      const v = geomCol.get(i);
      if(!v) continue;

      // DuckDB/Arrow renvoie g√©n√©ralement un Uint8Array pour un BLOB
      const bytes = (v instanceof Uint8Array) ? v : new Uint8Array(v);
      const geom = parseWKB(bytes);

      feats.push({ type:"Feature", properties:{}, geometry:geom });
    }

    return L.geoJSON({ type:"FeatureCollection", features:feats }, {
      pane,
      style: () => style
    });
  }

  try{
    setStatus("V√©rification DuckDB‚Ä¶");
    await assertOk(MVP_WORKER, "Worker");
    await assertOk(MVP_WASM, "WASM");

    setStatus("D√©marrage DuckDB (MVP)‚Ä¶");
    const worker = new Worker(MVP_WORKER);
    const db = new duckdb.AsyncDuckDB(new duckdb.ConsoleLogger(), worker);
    await db.instantiate(MVP_WASM);
    const conn = await db.connect();

    setStatus("Chargement : tampon 100 m‚Ä¶");
    tamponLayer = await parquetToLayer(db, conn, TAMPON_PARQUET, "tampon", {
      color:"#1f6feb", weight:1, fillColor:"#1f6feb", fillOpacity:0.30, opacity:0.85
    });
    tamponLayer.addTo(map);

    setStatus("Chargement : plans d‚Äôeau‚Ä¶");
    planLayer = await parquetToLayer(db, conn, PLAN_PARQUET, "plan", {
      color:"#1f6feb", weight:1.4, fillColor:"#1f6feb", fillOpacity:0.55, opacity:0.95
    });
    planLayer.addTo(map);

    document.getElementById("chkTampon").onchange = (e) =>
      e.target.checked ? map.addLayer(tamponLayer) : map.removeLayer(tamponLayer);
    document.getElementById("chkPlan").onchange = (e) =>
      e.target.checked ? map.addLayer(planLayer) : map.removeLayer(planLayer);

    const b = tamponLayer.getBounds();
    if(b?.isValid()) b.extend(planLayer.getBounds());
    if(b?.isValid()) map.fitBounds(b, { padding:[20,20] });

    setStatus("OK ‚Äì Parquet charg√© (WKB d√©cod√©).");

    window.addEventListener("beforeunload", async () => {
      try { await conn.close(); } catch {}
      try { await db.terminate(); } catch {}
      try { worker.terminate(); } catch {}
    });

  }catch(err){
    console.error(err);
    setStatus("Erreur (voir console).");
  }
</script>
</body>
</html>
